unit uStrategy;

interface

uses
  Classes, SysUtils, Generics.Collections;


type
  TStrategyType = (stUnknown, stAutomatic, stManual);
  TBaseStrategy = class
  private
    FAddPrice: Integer;
    FRounding: Boolean;
    procedure SetAddPrice(const Value: Integer);
    procedure SetRounding(const Value: Boolean);
  protected
    function GetType: TStrategyType; virtual; abstract;
  public
    property AddPrice: Integer read FAddPrice write SetAddPrice;
    property Rounding: Boolean read FRounding write SetRounding;
    property Type_: TStrategyType read GetType;
  end;

  TAutomaticStrategy = class(TBaseStrategy)
  private
    FStartTime: TDateTime;
    FCommitTime: TDateTime;
    procedure SetStartTime(const Value: TDateTime);
    procedure SetCommitTime(const Value: TDateTime);
  protected
    function GetType: TStrategyType; override;
  public
    property StartTime: TDateTime read FStartTime write SetStartTime;
    property CommitTime: TDateTime read FCommitTime write SetCommitTime;
  end;

  TManualStrategy = class(TBaseStrategy)
  private
    FHotKey: Integer;
    FCaption: string;
    procedure SetHotKey(const Value: Integer);
    procedure SetCaption(const Value: string);
  protected
    function GetType: TStrategyType; override;
  public
    property Caption :string read FCaption write SetCaption;
    property HotKey: Integer read FHotKey write SetHotKey;
  end;


  TStrategyManager = class(TList<TBaseStrategy>)
  private
    FBasePrice: Integer;
    FLastBidTime: TDateTime;
    FIsReadyCommit: Boolean;
    procedure ClearItems;
    procedure LoadFromFile;
    function RoundingPrice(APrice: Integer): Integer;
    function CreateStrategy(AType: TStrategyType): TBaseStrategy;
    function BuildDateTime(const AString: string): TDateTime;
    procedure SetIsReadyCommit(const Value: Boolean);
  public
    procedure InvokeStrategy(AStrategy: TBaseStrategy);
    procedure AfterConstruction; override;
    procedure BeforeDestruction; override;
    property LastBidTime: TDateTime read FLastBidTime;
    property IsReadyCommit: Boolean read FIsReadyCommit write SetIsReadyCommit;
  end;

  TAutoInvokeThread = class(TThread)
  private
    FStrategy: TAutomaticStrategy;
    procedure SetStrategy(const Value: TAutomaticStrategy);
  protected
    procedure Execute; override;
  public
    property Strategy: TAutomaticStrategy read FStrategy write SetStrategy;
  end;

var
  g_StrategyManager: TStrategyManager;


implementation

uses
  uPriceInfo, IniFiles, TypInfo, DateUtils, Forms, uHelp, USetting;

{ TManualStrategy }

function TManualStrategy.GetType: TStrategyType;
begin
  Result := stManual;
end;

procedure TManualStrategy.SetCaption(const Value: string);
begin
  FCaption := Value;
end;

procedure TManualStrategy.SetHotKey(const Value: Integer);
begin
  FHotKey := Value;
end;

{ TAutomaticStrategy }

function TAutomaticStrategy.GetType: TStrategyType;
begin
  Result := stAutomatic;
end;

procedure TAutomaticStrategy.SetCommitTime(const Value: TDateTime);
begin
  FCommitTime := Value;
end;

procedure TAutomaticStrategy.SetStartTime(const Value: TDateTime);
begin
  FStartTime := Value;
end;

{ TBaseStrategy }


procedure TBaseStrategy.SetAddPrice(const Value: Integer);
begin
  FAddPrice := Value;
end;

procedure TBaseStrategy.SetRounding(const Value: Boolean);
begin
  FRounding := Value;
end;


{ TStrategyManager }

procedure TStrategyManager.AfterConstruction;
begin
  inherited;
  LoadFromFile;
end;

procedure TStrategyManager.BeforeDestruction;
begin
  ClearItems;
  inherited;
end;

function TStrategyManager.BuildDateTime(const AString: string): TDateTime;
begin
  if Length(AString) = 8 then
  begin
    Result := EncodeDateTime(
            YearOf(Now),
            MonthOf(Now),
            DayOf(Now),
            StrToInt(Copy(AString,1,2)),
            StrToInt(Copy(AString,4,2)),
            StrToInt(Copy(AString,7,2)),
            0);
  end
  else if Length(AString) = 12 then
  begin
    Result := EncodeDateTime(
            YearOf(Now),
            MonthOf(Now),
            DayOf(Now),
            StrToInt(Copy(AString,1,2)),
            StrToInt(Copy(AString,4,2)),
            StrToInt(Copy(AString,7,2)),
            0);
  end;

end;

procedure TStrategyManager.ClearItems;
var
  I: Integer;
begin
  for I := 0 to Count - 1 do
  begin
    Self[I].Free;
  end;
  Clear;
end;

function TStrategyManager.CreateStrategy(AType: TStrategyType): TBaseStrategy;
begin
  Result := nil;
  case AType of
    stAutomatic: Result := TAutomaticStrategy.Create;
    stManual: Result := TManualStrategy.Create;
  end;
end;

procedure TStrategyManager.InvokeStrategy(AStrategy: TBaseStrategy);
var
  LPrice: Integer;
begin
  //执行策略
  LPrice := AStrategy.AddPrice + g_PriceInfoManager.LastPrice;

  if AStrategy.FRounding then
    LPrice := RoundingPrice(LPrice);

  g_PriceInfoManager.SetBidPrice(LPrice);
  //选中价格框
  MouseClick(g_ScreanPointSetting.GetPricePos);

  //输入价格
  ClearContent;
  KeyboardInput(IntToStr(LPrice));

  //获取验证码
  MouseClick(g_ScreanPointSetting.GetBidPos);
end;

procedure TStrategyManager.LoadFromFile;
var
  LIniFile: TIniFile;
  LCount: Integer;
  I: Integer;
  LType: TStrategyType;
  LSection: string;
  LStrategy: TBaseStrategy;
  LTime: TDateTime;
  LTemp: string;
  LFileName: string;
begin
  LFileName := ExtractFileDir(Application.ExeName) + '\Config.ini';
  Assert(FileExists(LFileName), '找不到配置文件:Config.ini');
  LIniFile := TIniFile.Create(LFileName);

  LCount := LIniFile.ReadInteger('Settings', 'StrategyCount', 0);
  FBasePrice := LIniFile.ReadInteger('Settings', 'BasePrice', 0);
  LTemp := LIniFile.ReadString('Settings', 'LastBidTime', '');
  FLastBidTime := BuildDateTime(LTemp);

  for I := 0 to LCount - 1 do
  begin
    LSection := 'Strategy' + IntToStr(I);
    LType := TStrategyType(GetEnumValue(TypeInfo(TStrategyType),
      ('st'+ LIniFile.ReadString(LSection, 'Type', 'unKnown'))));
    LStrategy := CreateStrategy(LType);
    Assert(Assigned(LStrategy), '策略类型配置错误');
    LStrategy.AddPrice := LIniFile.ReadInteger(LSection, 'AddPrice', 0);
    LStrategy.Rounding := StrToBool(LIniFile.ReadString(LSection, 'Rounding', 'False'));
    case LType of
      stAutomatic:
        begin
          LTemp := LIniFile.ReadString(LSection, 'StartTime', '');
          Assert(Length(LTemp)=8, '自动启动时间配置错误');
          LTime := BuildDateTime(LTemp);
          TAutomaticStrategy(LStrategy).StartTime := LTime;

          LTemp := LIniFile.ReadString(LSection, 'CommitTime', '');
          Assert(Length(LTemp)=8, '自动提交时间配置错误');
          LTime := BuildDateTime(LTemp);
          TAutomaticStrategy(LStrategy).CommitTime := LTime;
        end;
      stManual:
        begin
          TManualStrategy(LStrategy).HotKey :=
            LIniFile.ReadInteger(LSection, 'HotKey', 0);
          TManualStrategy(LStrategy).Caption :=
            LIniFile.ReadString(LSection, 'Caption', '未命名');
        end;
    end;
    Self.Add(LStrategy);
  end;
  LIniFile.Free;
end;

function TStrategyManager.RoundingPrice(APrice: Integer): Integer;
var
  LDelta: Integer;
begin
  Assert(APrice > FBasePrice, '价格小于警示价');
  Result := APrice;
  LDelta := APrice - FBasePrice;
  LDelta := LDelta mod 300;
  if LDelta <> 0 then
    Result := Result + 300 - LDelta;
end;

procedure TStrategyManager.SetIsReadyCommit(const Value: Boolean);
begin
  FIsReadyCommit := Value;
end;

{ TAutoInvokeThread }

procedure TAutoInvokeThread.Execute;
var
  LIsStart: Boolean;
  LIsCommit: Boolean;
begin
  inherited;
  FreeOnTerminate := True;
  LIsStart := False;
  LIsCommit := False;
  { TODO : 测试时去掉本地时间 }
  while not Assigned(FStrategy) or (not (LIsStart and LIsCommit)) do
  begin
    if Assigned(FStrategy) then
    begin
      if not LIsStart and {(FStrategy.StartTime <= Now) or}
       (FStrategy.StartTime <= g_PriceInfoManager.LastServerTime) then
      begin
        LIsStart := True;
        g_StrategyManager.InvokeStrategy(FStrategy);
      end;
    
      if not LIsCommit and {(FStrategy.CommitTime <= Now) or}
       (FStrategy.CommitTime <= g_PriceInfoManager.LastServerTime) and
       g_StrategyManager.IsReadyCommit then
      begin
        LIsCommit := True;
        MouseClick(g_ScreanPointSetting.GetSubmitPos);
      end;
    
    end;
    Sleep(100);
  end;

end;

procedure TAutoInvokeThread.SetStrategy(const Value: TAutomaticStrategy);
begin
  FStrategy := Value;
end;

initialization;
  g_StrategyManager := TStrategyManager.Create;

finalization
  if Assigned(g_StrategyManager) then
    g_StrategyManager.Free;
end.
